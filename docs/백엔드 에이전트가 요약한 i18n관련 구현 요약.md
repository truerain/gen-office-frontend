백엔드 에이전트가 요약한 i18n관련 구현 요약

•메시지 리소스는 DB tb_cm_message에 저장됨. 키는 (namespace, message_cd, lang_cd) 조합.
•로케일 결정 우선순위: X-Lang 헤더 → Accept-Language → (추후 사용자 언어) → 기본 ko.
•응답 헤더에 Content-Language가 항상 내려감.
•에러 응답은 i18n 메시지를 포함한 표준 포맷으로 내려감.
에러 응답 포맷
{
  "code": "NOT_FOUND",
  "messageKey": "user.not_found",
  "message": "사용자를 찾을 수 없습니다",
  "locale": "ko",
  "path": "/api/users/1",
  "timestamp": "2026-02-09T09:12:34+09:00",
  "traceId": null
}

프론트 적용 가이드
•API 호출 시 로케일을 X-Lang 헤더로 전달(예: ko, en, en-US).
•에러 표시 시 message를 우선 사용하고, 필요하면 messageKey로 클라이언트 i18n fallback 가능.
•Content-Language 값으로 서버가 적용한 로케일을 확인 가능.
현재 정의된 메시지 키
•user.not_found
•menu.not_found
•common.internal_error



1. 로케일 결정 및 저장

앱 전역 상태(예: i18n store)에서 현재 로케일을 관리
우선순위는 다음으로 추천
사용자가 선택한 로케일(설정)
브라우저 navigator.language
기본 ko
2. API 요청 시 X-Lang 자동 주입

Axios/Fetch 공통 래퍼에서 헤더 주입
예: X-Lang: currentLocale
Accept-Language는 서버가 참고만 하므로 굳이 세팅할 필요는 없음
3. 응답 Content-Language 처리

응답 인터셉터에서 Content-Language 읽기
서버가 적용한 로케일을 클라이언트 상태와 다를 경우:
상태를 갱신하거나
로그/디버깅 목적으로 저장
4. 에러 처리

에러 응답의 message를 우선 사용자에게 표시
message가 없거나 빈 값이면 messageKey를 로컬 i18n에서 lookup
그래도 없으면 fallback: code 또는 일반 오류 메시지
구현 예시 (설계 포인트)

apiClient.ts

요청 인터셉터: X-Lang 주입
응답 인터셉터: Content-Language 저장
에러 처리 유틸로 표준 포맷 파싱
i18n.ts

로컬 번역 리소스와 messageKey 대응
질문

현재 API 호출 래퍼(axios/fetch)가 어디에 있나요?
로케일 상태는 어디에서 관리하고 있나요? (예: Redux, Zustand, Context, i18n 라이브러리)
원하시면 실제 코드 위치를 보고 구체적인 패치로 제안해 드릴게요.




 “기본 번역 파일 + DB 오버라이드” 구조로 정리해서 운영과 안정성을 같이 가져가. 흐름을 단순하게 설명하면 아래 4단계야.

기본 구조

정적 리소스 (파일)

common.json, common.json
앱이 바로 렌더링 가능한 최소 문구
DB 리소스 (오버라이드)

운영에서 수정되는 문구
키 단위로 기본 파일을 덮어씀
초기 로딩 순서

앱 시작: 파일 리소스 로딩 → 화면 즉시 렌더
그 다음 DB 리소스 fetch → 도착하면 merge & re-render
캐시/버전

DB 응답에 updatedAt 혹은 version 포함
localStorage에 저장 → 버전이 다를 때만 다시 fetch
구체적인 런타임 흐름

App boot
loadStaticResources()
i18n.addResources(...)
Background fetch
GET /api/i18n?locale=ko&ns=common
mergeDeep(base, override)
i18n.addResources(...)
폴더/파일 예시

src/i18n/
index.ts (init)
loader.ts (static + remote merge)
types.ts
common.json
common.json
운영 측면

관리자 UI에서 키/번역 수정 → DB 저장
클라이언트는 버전 비교해서 필요한 경우만 재요청
장점 요약

장애 시 기본 문구는 유지
운영 중 수정은 실시간 반영
캐시로 네트워크 비용 최소화
원하면 지금 프로젝트 구조 기준으로

현황 요약 (apps/demo 기준)

i18n은 react-i18next 기반이고, 로컬 번들 + /api/i18n 원격 번들을 병행합니다. index.ts
API 래퍼는 단일 fetch 기반이며 헤더 주입/에러 파싱이 없습니다. http.ts
에러 노출은 대부분 Error.message를 그대로 보여줍니다. apps/demo/src/pages/**
필수 변경 포인트 (백엔드 i18n 사양 반영)

요청 헤더에 X-Lang 주입
대상: http.ts
현재는 Content-Type만 설정 중이므로 X-Lang을 공통 주입해야 합니다.
소스: i18n의 현재 로케일. index.ts에 getCurrentLocale() 같은 간단한 getter를 추가하는 게 깔끔합니다.
응답 헤더 Content-Language 확인 가능하게 저장
대상: http.ts
매 응답에서 res.headers.get('content-language')를 읽고
모듈 내부 상태로 저장 후 getter 제공, 또는
i18n 상태와 다를 때 로그/디버깅 용도로 노출
요구사항은 “확인 가능”이므로 저장 + getter 정도면 충분합니다.
표준 에러 포맷 파싱 + message 우선
대상: http.ts
res.ok === false일 때 JSON을 파싱하여
message가 있으면 Error.message에 반영
없으면 messageKey를 붙여 fallback 가능하게 만듦
이를 위해 HttpError 타입(또는 class)를 만들어
code, messageKey, locale, path, timestamp, traceId, contentLanguage 등을 보관하는 것이 좋습니다.
클라이언트 i18n fallback 연결
대상: 에러를 UI로 보여주는 곳
message가 비어있을 때만 messageKey로 i18n lookup하도록 헬퍼를 하나 두는 것을 권장합니다.
예: errorMessage.ts에 getErrorMessage(error, t) 형태.
로컬 번들에 최소 키 추가
서버 키: user.not_found, menu.not_found, common.internal_error
common.json 및 common.json에 추가해두면 fallback 안정성 확보됩니다.
현재 ko JSON은 인코딩이 깨진 텍스트가 많아 보입니다. 이 상태에서 새 키를 추가하면 관리가 어렵습니다. 먼저 인코딩 문제를 확인하는 것을 권장합니다.
보완하면 좋은 선택 사항

remote.ts의 /api/i18n 호출도 X-Lang을 같이 보내면 서버 로케일 정책과 더 일관됩니다.
React Query 전역 onError에서 표준 에러를 처리하고 알림으로 통일할 수도 있습니다. (현재는 화면별 alert가 많음)
내가 구현할 수 있는 범위

http.ts에 X-Lang, Content-Language, 표준 에러 파싱, HttpError 추가
index.ts에 getCurrentLocale() 추가
errorMessage.ts 같은 헬퍼 추가
로컬 번들에 최소 키 추가
원하면 바로 코드 변경 들어가겠습니다. 진행해도 될까요?
가능하면 아래 두 가지도 알려주세요.

X-Lang 값은 i18n.language 그대로 쓰면 되나요, 아니면 별도 매핑(예: en-US -> en)이 필요한가요?
에러 UI는 현재처럼 alert로 둘지, 전역 알림으로 통일할지 선호가 있나요?