import fs from 'node:fs';
import path from 'node:path';

const repoRoot = process.cwd();
const packagesDir = path.join(repoRoot, 'packages');
const uiCoreDir = path.join(packagesDir, 'ui', 'src', 'core');
const componentTokenDir = path.join(
  packagesDir,
  'theme',
  'src',
  'styles',
  'tokens',
  'components',
);
const outputPath = path.join(
  packagesDir,
  'theme',
  'src',
  'styles',
  'tokens',
  'MAPPING.md',
);

const CONTENT_EXTENSIONS = new Set(['.css', '.ts', '.tsx']);

function listFiles(dir) {
  const results = [];
  const stack = [dir];
  while (stack.length > 0) {
    const current = stack.pop();
    if (!current || !fs.existsSync(current)) continue;
    const entries = fs.readdirSync(current, { withFileTypes: true });
    for (const entry of entries) {
      const fullPath = path.join(current, entry.name);
      if (entry.isDirectory()) {
        stack.push(fullPath);
        continue;
      }
      if (CONTENT_EXTENSIONS.has(path.extname(entry.name))) {
        results.push(fullPath);
      }
    }
  }
  return results;
}

function listDirs(dir) {
  if (!fs.existsSync(dir)) return [];
  return fs
    .readdirSync(dir, { withFileTypes: true })
    .filter((entry) => entry.isDirectory())
    .map((entry) => path.join(dir, entry.name));
}

function extractVarTokens(content) {
  const tokens = new Set();
  const regex = /var\(--([a-zA-Z0-9-]+)\)/g;
  let match = regex.exec(content);
  while (match) {
    tokens.add(`--${match[1]}`);
    match = regex.exec(content);
  }
  return tokens;
}

function extractDefinedTokens(content) {
  const tokens = new Set();
  const regex = /--([a-zA-Z0-9-]+)\s*:/g;
  let match = regex.exec(content);
  while (match) {
    tokens.add(`--${match[1]}`);
    match = regex.exec(content);
  }
  return tokens;
}

function toRepoPath(filePath) {
  return path.relative(repoRoot, filePath).replace(/\\/g, '/');
}

function buildTokenUsageMap(files) {
  const usage = new Map();
  for (const filePath of files) {
    const content = fs.readFileSync(filePath, 'utf8');
    const tokens = extractVarTokens(content);
    if (tokens.size === 0) continue;
    for (const token of tokens) {
      if (!usage.has(token)) usage.set(token, new Set());
      usage.get(token).add(toRepoPath(filePath));
    }
  }
  return usage;
}

function buildUiCoreUsage() {
  const components = listDirs(uiCoreDir)
    .map((dir) => ({
      name: path.basename(dir),
      dir,
    }))
    .sort((a, b) => a.name.localeCompare(b.name));

  const result = [];
  for (const component of components) {
    const files = listFiles(component.dir).filter((file) =>
      file.endsWith('.css'),
    );
    if (files.length === 0) continue;
    const tokenSet = new Set();
    const usageFiles = new Set();
    for (const filePath of files) {
      const content = fs.readFileSync(filePath, 'utf8');
      extractVarTokens(content).forEach((token) => tokenSet.add(token));
      usageFiles.add(toRepoPath(filePath));
    }
    if (tokenSet.size === 0) continue;
    result.push({
      name: component.name,
      usageFiles: Array.from(usageFiles).sort(),
      tokens: Array.from(tokenSet).sort(),
    });
  }
  return result;
}

function buildComponentTokenUsage(tokenUsageMap) {
  if (!fs.existsSync(componentTokenDir)) return [];
  const files = fs
    .readdirSync(componentTokenDir, { withFileTypes: true })
    .filter((entry) => entry.isFile() && entry.name.endsWith('.css'))
    .map((entry) => path.join(componentTokenDir, entry.name))
    .sort((a, b) => a.localeCompare(b));

  const result = [];
  for (const filePath of files) {
    const content = fs.readFileSync(filePath, 'utf8');
    const tokens = Array.from(extractDefinedTokens(content)).sort();
    if (tokens.length === 0) continue;
    const usageFiles = new Set();
    for (const token of tokens) {
      const filesForToken = tokenUsageMap.get(token);
      if (!filesForToken) continue;
      filesForToken.forEach((file) => usageFiles.add(file));
    }
    result.push({
      name: path.basename(filePath, '.css'),
      source: toRepoPath(filePath),
      tokens,
      usageFiles: Array.from(usageFiles).sort(),
    });
  }
  return result;
}

function formatList(values) {
  if (values.length === 0) return '(none)';
  return values.map((value) => `\`${value}\``).join(', ');
}

function formatPathList(values) {
  if (values.length === 0) return '(none)';
  return values.map((value) => `\`${value}\``).join(', ');
}

function generateMarkdown(componentTokens, uiCoreUsage) {
  const lines = [];
  lines.push('# Token Mapping');
  lines.push('');
  lines.push(
    '이 문서는 component 토큰과 실제 사용 위치를 빠르게 확인하기 위한 매핑표입니다.',
  );
  lines.push('');
  lines.push('Generated by `node scripts/generate-token-mapping.mjs`.');
  lines.push('');

  lines.push('## Component Tokens');
  if (componentTokens.length === 0) {
    lines.push('- (none)');
  } else {
    for (const item of componentTokens) {
      lines.push('');
      lines.push(`## ${item.name} (component tokens)`);
      lines.push(`- Source: \`${item.source}\``);
      lines.push(`- Tokens: ${formatList(item.tokens)}`);
      lines.push(`- Usage files: ${formatPathList(item.usageFiles)}`);
    }
  }

  lines.push('');
  lines.push('## UI Core Component Usage');
  if (uiCoreUsage.length === 0) {
    lines.push('- (none)');
  } else {
    for (const item of uiCoreUsage) {
      lines.push('');
      lines.push(`## ${item.name} (ui core usage)`);
      lines.push(`- Usage files: ${formatPathList(item.usageFiles)}`);
      lines.push(`- Tokens: ${formatList(item.tokens)}`);
    }
  }

  lines.push('');
  return `${lines.join('\n')}\n`;
}

const allFiles = listFiles(packagesDir);
const tokenUsageMap = buildTokenUsageMap(allFiles);
const componentTokens = buildComponentTokenUsage(tokenUsageMap);
const uiCoreUsage = buildUiCoreUsage();
const markdown = generateMarkdown(componentTokens, uiCoreUsage);

fs.writeFileSync(outputPath, markdown, 'utf8');
console.log(`Updated ${toRepoPath(outputPath)}`);
